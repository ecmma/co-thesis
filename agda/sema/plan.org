* A flânerie through coinductive semantics

** TODO Partial /{Codata.Sized.Partial}/
  - [X] monad /{.Effectful}/
    + [X] map *[(A -> B) -> Delay (Maybe A) -> Delay (Maybe B)]*
    + [X] bind *[Delay (Maybe A) -> (A -> Delay (Maybe B) -> Delay (Maybe B)]*
    + [X] functor *[RawFunctor (λ A → Delay (Maybe A))]*
    + [X] monad *[RawMonad (λ A → Delay (Maybe A))]*
  - [-] weak bisimilarity /{.Bisimilarity}/
    + [-] equivalence /{.Relation.Binary.Equivalence}/
      * [X] reflexivity
      * [X] symmetry
      * [ ] transitivity
    + [-] reasoning /{.Reasoning}/
      # Maybe, instead of "plain" functions, I'd be better off using data+constructors for reasoning
      * [X] transitivity by propositional equality *[x ≡ y → Bisim i k y z → Bisim i k x z]*
      * [ ] transitivity by bisimilarity *[(i ⊢ x ≈ y) → (i ⊢ y ≈ z) → (i ⊢ x ≈ z)]*
  - [-] properties {.Relation}
    + [ ] convergence /{.Binary - .Unary}/
      * [ ] prove ≈-⇓⇓, that is for any two `x` and `y` (x≈y) <=> (x⇓ <=> y⇓) 
    + [X] `All` predicate 
      * [X] bind preserves `All`
      * [X] reasoning

** TODO Lambda /{Lambda}/
  - [X] syntax  /{.Syntax}/
    + [X] terms 
    + [X] values
  - [X] types /{.Types}/
    + [X] coinductive def of `Ty`
    + [X] properties /{.Properties}/
      * [X] `HasType` predicate
       - [X] well-typedness of Ω
      * [X] well foundedness 
       - [X] if `v` is well-formed w.r.t. some env, then `v` is not bisimilar to `fail`.
    + [X] bisimilarity /{.Bisimilarity}/ 
  - [X] semantics /{.Semantics}/
    + [X] functional 
      * [X] eval *[Tm n -> Env n -> Delay (Maybe Value)]*
	- [X] properties
	  + [X] Ω-loops *[∀ {i} -> i ⊢ (eval Ω []) ≈ never]*
      	  + [X] eval-wf *[Γ ⊢ t ∈ σ -> WFₑ Γ ρ -> All (WFᵥ σ) i (eval t ρ)]*
    + [ ] other forms of semantics? 

** TODO Imp /{Imp}/
  - [X] syntax /{.Syntax}/
    + [X] arithmetic expressions
    + [X] boolean expressions
    + [X] commands
  - [-] semantics  /{.Semantics}/
    + [X] functional
      * [X] aeval (AExp -> Store -> Maybe Z)
      * [X] beval (BExp -> Store -> Maybe Bool)
      * [x] ceval (Command -> Store -> Delay (Maybe Store))
    + [ ] other forms (non functional) of semantics?
      * [ ] relational?
  - [ ] optimizations
    + [ ] liveness
    + [ ] dead-code elimination
      * [ ] dce (Command -> Command)
      * [ ] prove semantic preservation
    + [ ] register allocation
      * [ ] regalloc (Command -> Command)
      * [ ] prove semantic preservation

** TODO Stack /{Stack}/
  - [X] syntax /{.Syntax}/
  - [ ] semantics /{.Semantics}/
    + [-] relational 
      * [X] transitional (small-step)
      * [ ] ?
    + [ ] functional?

** TODO ImpToStack /{Stack.Imp}/
  - [-] compiler /{.Compiler}/
    + [x] comp-aexp
    + [x] comp-bool
    + [x] comp-com
    + [ ] correctness
      * [ ] prove comp-aexp-correct 
      * [ ] prove comp-bexp-correct 
      * [ ] prove comp-com-correct 
