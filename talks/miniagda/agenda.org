#+title: Agenda presentazione MiniAgda
#+date: 2022-10-03

* Introduzione
** Perché
ossia, /structural descent/ e /guardedness/ (spiegata dal Prof?).
** Citazioni agli approcci alternativi
/guard condition/ di Coq e /foetus/ di Agda. Entrambi sono *untyped*; che svantaggi hanno? 

* MiniAgda 
** Intuizione
indiciare i tipi con una /size/ che indica *un upper bound* sulla dimensione
dei valori di quel tipo; questo permette di controllare la terminazione delle
definizioni di *funzioni ricorsive* controllando che la dimensione degli
argomenti sia decrescente ([1]) [2]. 

** Perché MiniAgda
è tra le prime implementazioni di un sistema basato su sized-types non
simply-typed. Il punto di vista del paper (e pertanto anche della
presentazione) è più implementativo che strettamente teorico.

* Tipi induttivi 
** Intuizione
  1. Associare una /taglia/ ~i~ ad ogni tipo induttivo ~D~;
  2. Controllare che la taglia diminuisca nelle chiamate ricorsive.  

** Implementazione
  + Concetto di /altezza/ ed esempio i numeri naturali (in generale, non in MiniAgda).

  + Come una taglia è associata all'altezza: un elemento ~d \in D^i~ di taglia
    ~i~ ha un altezza che è strettamente minore di ~i~; ossia la taglia ~i~ di
    ~d~ è un *upper bound* sulla sua altezza.

  + Migliorie derivanti dall'uso di un sistema dependently typed,
    implementazione dell'esempio in MiniAgda, ossia i tipi sono ~Size->Set~;
    esempio definizione ~pred~ con /dot pattern/.

  + Parametricità delle funzioni rispetto alle taglie: in particolare, "The
    result of a function should never be influenced by the size of its
    arguments, and we should not be allowed to pattern match on sizes." Mentre
    il risultato deve essere indipendente dalla taglia, il suo /tipo/ dipende
    da esso.
    # Decidere se includere anche una discussione sull'uso dei tipi intersezione.

  # Nell'articolo, nella sezione successiva, non c'è una vera e propria
  # dimostrazione del fatto che i sized-types permettono in generale di
  # controllare la terminazione di una definizione: ci sono due esempi (la
  # definizione della funzione ~minus~ e la definizione della funzione ~div~) e
  # semplicemente viene mostrato il fatto che nella definizione le taglie dei
  # tipi nelle chiamate ricorsive diminuiscono; questo fatto viene esposto
  # senza dire "questa cosa non si può fare negli altri sistemi", probabilmente
  # viene lasciato implicitamente inteso per chi sa perfettamente cosa si può e
  # non si può fare con la guardedness. La stessa cosa viene fatta nella
  # sezione successiva, in cui viene specificato però che le definizioni
  # mutuali di tipi induttivi (cosa che viene fatta con Rose Trees e liste)
  # sono più semplici da fare con sized-types piuttosto che con Coq e Agda
  # pre-sized types; sicuramente questo va incluso nella discussione: decidere
  # come.
 
* Tipi co-induttivi
L'esempio principale di tipo co-induttivo è lo /stream/, che definiamo in MiniAgda
      ~codata Stream ++(A : Set) : Set~
      ~{ cons : A -> Stream A -> Stream A }~

"Una funzione che produce uno stream *non può* terminare, perché deve produrre
una quantità infinita di dati. Invece della terminazione, richiediamo la
*produttività*, ossia che la prossima porzione dello stream sia prodotto in
tempo finito." 

** Guardedness sintattica
  + Esempio di definizione co-ricorsiva /guarded/: la funzione ~repeat a = cons a (repeat a)~.

  + Esempio in cui la /guardedness/ non basta: ~repeat f a = cons a (f (repeat a))~. 
    La produttività della funzione dipende da ~f~: la definizione è
    produttiva se e solo se ~f~ incrementa o mantiene l'altezza dello stream. 
    Le condizioni di /guardedness/ sintattiche, tuttavia, non riescono a
    catturare questo fatto, come invece fanno i sized-types.

** Guardedness con taglie
"What is counted by the size ~i~ of a [co-data type] is a *lower bound* on the
number of coconstructors or guards, which we call the /depth/ of the
[co-data type]." In altre parole, un elemento ~d \in D^i~ con ~D^i~ induttivo
ha altezza _al più_ ~i~ (in realtà ~pred i~), mentre se ~D^i~ è co-induttivo,
allora ~d~ ha altezza _almeno_ ~i~. 
  
  + Esempio: ~sized codata Stream~.

  # What is counted by the size ~i~ of a ~Stream~ is a *lower bound* on the
  # number of coconstructors or guards, which we call the *depth* of the
  # stream. A fully constructed stream will always have size ~#~, but during
  # the construction of the stream we reason with approximations, i.e., streams
  # which have depth ~i~ for some arbitrary ~i~. This is dual to the definition
  # of recursive functions over inductive types: once *a function* is defined,
  # it can handle trees of arbitrary height, but to perceive their termination
  # we assume during their construction that they can only handle trees up to
  # size ~i~, and derive from this that they also handle trees up to size ~i+1~
  # as well.
  # 
  # "Take home message": anche se gli elementi di tipi co-induttivi possono
  # avere altezza potenzialmente infinita, le definizioni delle funzioni si
  # basano sui termini ~i~ che approssimano arbitrariamente l'altezza generale
  # dell'elemento; ossia, fanno esattamente come le funzioni ricorsive?
  

# Questa sezione è molto improntata su Agda (tramite MiniAgda): viene mostrato
# come i /sized-types/ possono essere introdotti in un sistema puro come Agda
# ([...] we demonstrate that sized types harmonize with predicates and then
# with large eliminations). Decidere se includere. 
* Dependent types, dimostrazioni e large eliminations
** Dimostrazioni
  + Esempio: bisimilarità tra sized streams. 
  ~ sized codata StreamEq (A : Set) : (i : Size) -> Stream A i -> Stream A i -> Set ~
  ~ { ~
  ~	bisim: [i : Size] -> [a : A] -> [as : Stream A i] -> [bs : Stream A i] -> StreamEq A i as bs -> StreamEq A ($ i) (cons A i a as) (cons A i a bs) ~
  ~ } ~
  Deve essere definita come una famiglia coinduttiva parametrizzata dal tipo ~A~ e dalla taglia ~i~. 
  
 

# [1]: il paper dice che questo fatto comporta "by well-foundedness" che la
# funzione sia terminante. E' il caso di analizzare nel dettaglio questo
# fatto? 
# [2]: nell'introduzione il paper non cita in che modo verranno
# utilizzati i sized-types per controllare la produttività di definizioni
# co-induttive.
# [3]: l'esempio 
