Publication Type,Authors,Book Authors,Group Authors,Book Group Authors,Researcher Ids,ORCIDs,Book Editors,Author - Arabic,Article Title,Article Title - SciELO,Article Title - SciELO,Article Title - Chinese,Article Title - Russian,Patent Number,Patent Assignee,Source Title - Arabic,Source Title,Source Title - Korean,Book Series Title,Book Series Subtitle,Volume,Issue,Special Issue,Meeting Abstract,Start Page,End Page,Article Number,DOI,Book DOI,Early Access Date,Supplement,Publication Date,Publication Year,Abstract,Abstract - Foreign,Abstract - English Transliteration ,Abstract - Foreign,Abstract - Korean,Conference Title,Conference Date,Conference Sponsor,Conference Location,"Times Cited, WoS Core","Times Cited, CSCD ","Times Cited, RSCI","Times Cited, ARCI","Times Cited, BCI","Times Cited, SCIELO","Times Cited, All Databases",180 Day Usage Count,Since 2013 Usage Count,ISSN,eISSN,ISBN,UT (Unique ID),Pubmed Id
J,"Dagnino, Francesco",,,,,,,,A Meta-theory for Big-step Semantics,,,,,,,,ACM TRANSACTIONS ON COMPUTATIONAL LOGIC,,,,23,3,,,,,20,10.1145/3522729,,,,JUL 2022,2022,"It is well known that big-step semantics is not able to distinguish stuck and non-terminating computations. This is a strong limitation as it makes it very difficult to reason about properties involving infinite computations, such as type soundness, which cannot even be expressed.We show that this issue is only apparent: the distinction between stuck and diverging computations is implicit in any big-step semantics and it just needs to be uncovered. To achieve this goal, we develop a systematic study of big-step semantics: we introduce an abstract definition of what a big-step semantics is, we define a notion of computation by formalizing the evaluation algorithm implicitly associated with any big-step semantics, and we show how to canonically extend a big-step semantics to characterize stuck and diverging computations.Building on these notions, we describe a general proof technique to show that a predicate is sound, that is, it prevents stuck computation, with respect to a big-step semantics. One needs to check three properties relating the predicate and the semantics, and if they hold, the predicate is sound. The extended semantics is essential to establish this meta-logical result but is of no concerns to the user, who only needs to prove the three properties of the initial big-step semantics. Finally, we illustrate the technique by several examples, showing that it is applicable also in cases where subject reduction does not hold, and hence the standard technique for small-step semantics cannot be used.",,,,,,,,,0,0,0,0,0,0,0,,,1529-3785,1557-945X,,WOS:000831583400007,
J,"Racordon, Dimitri; Shabalin, Denys; Zheng, Daniel; Abrahams, Dave; Saeta, Brennan",,,,,,,,Implementation Strategies for Mutable Value Semantics,,,,,,,,JOURNAL OF OBJECT TECHNOLOGY,,,,21,2,,,,,,10.5381/jot.2022.21.2.a2,,,,2022,2022,"Mutable value semantics is a programming discipline that upholds the independence of values to support local reasoning. In the discipline's strictest form, references become second-class citizens: they are only created implicitly, at function boundaries, and cannot be stored in variables or object fields. Hence, variables can never share mutable state. Unlike pure functional programming, however, mutable value semantics allows part-wise in-place mutation, thereby eliminating the memory traffic usually associated with functional updates of immutable data.This paper presents implementation strategies for compiling programs with mutable value semantics into efficient native code. We study Swift, a programming language based on that discipline, through the lens of a core language that strips some of Swift's features to focus on the semantics of its value types. The strategies that we introduce leverage the inherent properties of mutable value semantics to unlock aggressive optimizations. Fixed-size values are allocated on the stack, thereby enabling numerous off-the-shelf compiler optimizations, while dynamically sized containers use copy-on-write to mitigate copying costs.",,,,,,,,,0,0,0,0,0,0,0,,,1660-1769,,,WOS:000790965800003,
J,"Zakowski, Yannick; Beck, Calvin; Yoon, Irene; Zaichuk, Ilia; Zaliva, Vadim; Zdancewic, Steve",,,,,"Zaliva, Vadim/0000-0002-9145-3288; Zakowski, Yannick/0000-0003-4585-6470; Yoon, Irene/0000-0003-3388-1257; Zdancewic, Steve/0000-0002-3516-1512",,,"Modular, Compositional, and Executable Formal Semantics for LLVM IR",,,,,,,,PROCEEDINGS OF THE ACM ON PROGRAMMING LANGUAGES-PACMPL,,,,5,,,,,,67,10.1145/3473572,,,,AUG 2021,2021,"This paper presents a novel formal semantics, mechanized in Coq, for a large, sequential subset of the LLVM IR. In contrast to previous approaches, which use relationally-specified operational semantics, this new semantics is based on monadic interpretation of interaction trees, a structure that provides a more compositional approach to defining language semantics while retaining the ability to extract an executable interpreter. Our semantics handles many of the LLVM IR's non-trivial language features and is constructed modularly in terms of event handlers, including those that deal with nondeterminism in the specification. We show how this semantics admits compositional reasoning principles derived from the interaction trees equational theory of weak bisimulation, which we extend here to better deal with nondeterminism, and we use them to prove that the extracted reference interpreter faithfully refines the semantic model. We validate the correctness of the semantics by evaluating it on unit tests and LLVM IR programs generated by HELIX.",,,,,,,,,0,0,0,0,0,0,0,,,,2475-1421,,WOS:000687133800007,
J,"Paraskevopoulou, Zoe; Li, John M.; Appel, Andrew W.",,,,,,,,Compositional Optimizations for CertiCoq,,,,,,,,PROCEEDINGS OF THE ACM ON PROGRAMMING LANGUAGES-PACMPL,,,,5,,,,,,86,10.1145/3473591,,,,AUG 2021,2021,"Compositional compiler verification is a difficult problem that focuses on separate compilation of program components with possibly different verified compilers. Logical relations are widely used in proving correctness of program transformations in higher-order languages; however, they do not scale to compositional verification of multi-pass compilers due to their lack of transitivity. The only known technique to apply to compositional verification of multi-pass compilers for higher-order languages is parametric inter-language simulations (PILS), which is however significantly more complicated than traditional proof techniques for compiler correctness. In this paper, we present a novel verification framework for lightweight compositional compiler correctness. We demonstrate that by imposing the additional restriction that program components are compiled by pipelines that go through the same sequence of intermediate representations, logical relation proofs can be transitively composed in order to derive an end-to-end compositional specification for multi-pass compiler pipelines. Unlike traditional logical-relation frameworks, our framework supports divergence preservationDeven when transformations reduce the number of program steps. We achieve this by parameterizing our logical relations with a pair of relational invariants.We apply this technique to verify a multi-pass, optimizing middle-end pipeline for CertiCoq, a compiler from Gallina (Coq's specification language) to C. The pipeline optimizes and closure-converts an untyped functional intermediate language (ANF or CPS) to a subset of that language without nested functions, which can be easily code-generated to low-level languages. Notably, our pipeline performs more complex closure-allocation optimizations than the state of the art in verified compilation. Using our novel verification framework, we prove an end-to-end theorem for our pipeline that covers both termination and divergence and applies to whole-program and separate compilation, even when different modules are compiled with different optimizations. Our results are mechanized in the Coq proof assistant.",,,,,,,,,1,0,0,0,0,0,1,,,,2475-1421,,WOS:000687133800026,
J,"Ancona, Davide; Franceschini, Luca; Ferrando, Angelo; Mascardi, Viviana",,,,"Ferrando, Angelo/ABC-9750-2020","Ferrando, Angelo/0000-0002-8711-4670",,,RML: Theory and practice of a domain specific language for runtime verification,,,,,,,,SCIENCE OF COMPUTER PROGRAMMING,,,,205,,,,,,102610,10.1016/j.scico.2021.102610,,JAN 2021,,MAY 1 2021,2021,"Runtime verification (RV) is an approach to verification consisting in dynamically checking that the event traces generated by single runs of a system under scrutiny (SUS) are compliant with the formal specification of its expected correct behavior.RML (Runtime Monitoring Language) is a simple but powerful Domain Specific Language (DSL) for RV which is able to express non context-free properties. When designing RML, particular care has been taken to favor abstraction and simplicity, to better support reusability and portability of specifications and interoperability of the monitors generated from them; this is mainly achieved by decoupling the two problems of property specification and event generation, and by minimizing the available primitive constructs.The formalization and implementation of RML is based on a trace calculus with a fully deterministic rewriting semantics. The semantics of RML is defined by translation into such a calculus, which, in fact, is used as intermediate representation (IR) by the RML compiler. The effectiveness of RML and its methodological impact on RV are presented through interesting patterns that can be adapted to different contexts requiring verification of standard properties. A collection of tested examples is provided, together with benchmarks showing that the deterministic semantics and the performed dynamic optimizations based on the laws of the trace calculus significantly improve the performances of the generated monitors. (C) 2021 Elsevier B.V. All rights reserved.",,,,,,,,,0,0,0,0,0,0,0,,,0167-6423,1872-7964,,WOS:000632572100004,
C,"Cohen, Liron",,,,,"Cohen, Liron/0000-0002-6608-3000","Platzer, A; Sutcliffe, G",,Non-well-founded Deduction for Induction and Coinduction,,,,,,,,"AUTOMATED DEDUCTION, CADE 28",,Lecture Notes in Artificial Intelligence,,12699,,,,3,24,,10.1007/978-3-030-79876-5_1,,,,2021,2021,"Induction and coinduction are both used extensively within mathematics and computer science. Algebraic formulations of these principles make the duality between them apparent, but do not account well for the way they are commonly used in deduction. Generally, the formalization of these reasoning methods employs inference rules that express a general explicit (co)induction scheme. Non-well-founded proof theory provides an alternative, more robust approach for formalizing implicit (co)inductive reasoning. This approach has been extremely successful in recent years in supporting implicit inductive reasoning, but is not as well-developed in the context of coinductive reasoning. This paper reviews the general method of non-well-founded proofs, and puts forward a concrete natural framework for (co)inductive reasoning, based on (co)closure operators, that offers a concise framework in which inductive and coinductive reasoning are captured as we intuitively understand and use them. Through this framework we demonstrate the enormous potential of non-well-founded deduction, both in the foundational theoretical exploration of (co)inductive reasoning and in the provision of proof support for (co)inductive reasoning within (semi-)automated proof tools.",,,,,28th International Conference on Automated Deduction (CADE)28th International Conference on Automated Deduction (CADE),"JUL 11-16, 2021JUL 11-16, 2021",,"Carnegie Mellon Univ, ELECTR NETWORKCarnegie Mellon Univ, ELECTR NETWORK",0,0,0,0,0,0,0,,,0302-9743,1611-3349,978-3-030-79876-5; 978-3-030-79875-8,WOS:000693448800001,
J,"Dagnino, Francesco",,,,,,,,FOUNDATIONS OF REGULAR COINDUCTION,,,,,,,,LOGICAL METHODS IN COMPUTER SCIENCE,,,,17,3,,,,,2,10.46298/LMCS-17(4:2)2021,,,,2021,2021,"Inference systems are a widespread framework used to define possibly recursive predicates by means of inference rules. They allow both inductive and coinductive interpretations that are fairly well-studied. In this paper, we consider a middle way interpretation, called regular, which combines advantages of both approaches: it allows non-well-founded reasoning while being finite. We show that the natural proof-theoretic definition of the regular interpretation, based on regular trees, coincides with a rational fixed point. Then, we provide an equivalent inductive characterization, which leads to an algorithm which looks for a regular derivation of a judgment. Relying on these results, we define proof techniques for regular reasoning: the regular coinduction principle, to prove completeness, and an inductive technique to prove soundness, based on the inductive characterization of the regular interpretation. Finally, we show the regular approach can be smoothly extended to inference systems with corules, a recently introduced, generalised framework, which allows one to refine the coinductive interpretation, proving that also this flexible regular interpretation admits an equivalent inductive characterisation.",,,,,,,,,1,0,0,0,0,0,1,,,1860-5974,,,WOS:000704827500002,
J,"DAGNINO, F. R. A. N. C. E. S. C. O.; ANCONA, D. A. V. I. D. E.; ZUCCA, E. L. E. N. A.",,,,"Ancona, Davide/U-6156-2018","Ancona, Davide/0000-0002-6297-2011",,,Flexible coinductive logic programming,,,,,,,,THEORY AND PRACTICE OF LOGIC PROGRAMMING,,,,20,6,SI,,818,833,PII S147106842000023X,10.1017/S147106842000023X,,,,NOV 2020,2020,"Recursive definitions of predicates are usually interpreted either inductively or coinductively. Recently, a more powerful approach has been proposed, calledflexible coinduction, to express a variety of intermediate interpretations, necessary in some cases to get the correct meaning. We provide a detailed formal account of an extension of logic programming supporting flexible coinduction. Syntactically, programs are enriched bycoclauses, clauses with a special meaning used to tune the interpretation of predicates. As usual, the declarative semantics can be expressed as a fixed point which, however, is not necessarily the least, nor the greatest one, but is determined by the coclauses. Correspondingly, the operational semantics is a combination of standard SLD resolution and coSLD resolution. We prove that the operational semantics is sound and complete with respect to declarative semantics restricted to finite comodels.",,,,,36th International Conference on Logic Programming (ICLP)36th International Conference on Logic Programming (ICLP),"SEP 20-25, 2020SEP 20-25, 2020",,ELECTR NETWORKELECTR NETWORK,2,0,0,0,0,0,2,,,1471-0684,1475-3081,,WOS:000571456800002,
J,"Ancona, Davide; Dagnino, Francesco; Rot, Jurriaan; Zucca, Elena",,,,"Ancona, Davide/U-6156-2018","Ancona, Davide/0000-0002-6297-2011; Dagnino, Francesco/0000-0003-3599-3535; ZUCCA, ELENA/0000-0002-6833-6470",,,A big step from finite to infinite computations,,,,,,,,SCIENCE OF COMPUTER PROGRAMMING,,,,197,,,,,,102492,10.1016/j.scico.2020.102492,,,,OCT 1 2020,2020,"We provide a construction that, given a big-step semantics describing finite computations and their observations, extends it to include infinite computations as well. The basic idea is that the finite behavior uniquely determines the infinite behavior once observations and their composition operators are fixed. Technically, the construction relies on the framework of inference systems with corules. The effectiveness and scope of the approach are illustrated by several examples. The correctness is formally justified by proving that, starting from a big-step semantics equivalent to a reference small-step semantics, this equivalence is preserved by the construction. (C) 2020 Elsevier B.V. All rights reserved.",,,,,European Conference on Object-Oriented Programming (ECOOP)European Conference on Object-Oriented Programming (ECOOP),"NOV 15-17, 2020NOV 15-17, 2020",,ELECTR NETWORKELECTR NETWORK,2,0,0,0,0,0,2,,,0167-6423,1872-7964,,WOS:000572347300009,
J,"Zuniga, Angel; Bel-Enguix, Gemma",,,,"Zúñiga, Angel/AAW-5331-2021; Bel-Enguix, Gemma/D-2685-2018","Zúñiga, Angel/0000-0002-6133-3883; Bel-Enguix, Gemma/0000-0002-1411-5736",,,Coinductive Natural Semantics for Compiler Verification in Coq,,,,,,,,MATHEMATICS,,,,8,9,,,,,1573,10.3390/math8091573,,,,SEP 2020,2020,"(Coinductive) natural semantics is presented as a unifying framework for the verification of total correctness of compilers in Coq (with the feature that a verified compiler can be obtained). In this way, we have a simple, easy, and intuitive framework; to carry out the verification of a compiler, using a proof assistant in which both cases are considered: terminating and non-terminating computations (total correctness).",,,,,,,,,0,0,0,0,0,0,0,,,,2227-7390,,WOS:000580212700001,
J,"Xia, Li-yao; Zakowski, Yannick; He, Paul; Hur, Chung-Kil; Malecha, Gregory; Pierce, Benjamin C.; Zdancewic, Steve",,,,,"Malecha, Gregory/0000-0003-3952-0807; Xia, Li-yao/0000-0003-2673-4400",,,Interaction Trees Representing Recursive and Impure Programs in Coq,,,,,,,,PROCEEDINGS OF THE ACM ON PROGRAMMING LANGUAGES-PACMPL,,,,4,,,,,,51,10.1145/3371119,,,,JAN 2020,2020,"Interaction trees (ITrees) are a general-purpose data structure for representing the behaviors of recursive 5 programs that interact with their environments. A coinductive variant of free monads, ITrees are built out of uninterpreted events and their continuations. They support compositional construction of interpreters from event handlers, which give meaning to events by defining their semantics as monadic actions. ITrees are expressive enough to represent impure and potentially nonterminating, mutually recursive computations, while admitting a rich equational theory of equivalence up to weak bisimulation. In contrast to other approaches such as relationally specified operational semantics. ITrees re executable via code extraction, making them suitable for debugging, testing, and implementing software artifacts that are amenable to formal verification.We have implemented ITrees and their associated theory as a Coq library, mechanizing classic domain- and category-theoretic results about program semantics, iteration, monadic structures, and equational reasoning. Although the internals of the library rely heavily on coinductive proofs, the interface hides these details so that clients can use and reason about ITrees without explicit use of Coq's coinduction tactics.To showcase the utility of our theory, we prove the termination-sensitive correctness of a compiler from a simple imperative source language to an assembly-like target whose meanings are given in an ITree-based denotational semantics. Unlike previous results using operational techniques, our bisimulation proof follows straightforwardly by structural induction and elementary rewriting via an equational theory of combinators for control-flow graphs.",,,,,,,,,18,0,0,0,0,0,18,,,,2475-1421,,WOS:000685202400052,
C,"Dagnino, Francesco; Bono, Viviana; Zucca, Elena; Dezani-Ciancaglini, Mariangiola",,,,"Dezani, Mariangiola/C-8066-2016","Dezani, Mariangiola/0000-0002-3341-0941; BONO, Viviana/0000-0002-2533-0511; Dagnino, Francesco/0000-0003-3599-3535; ZUCCA, ELENA/0000-0002-6833-6470","Muller, P",,Soundness conditions for big-step semantics,,,,,,,,PROGRAMMING LANGUAGES AND SYSTEMS ( ESOP 2020): 29TH EUROPEAN SYMPOSIUM ON PROGRAMMING,,Lecture Notes in Computer Science,,12075,,,,169,196,,10.1007/978-3-030-44914-8_7,,,,2020,2020,"We propose a general proof technique to show that a predicate is sound, that is, prevents stuck computation, with respect to a big-step semantics. This result may look surprising, since in big-step semantics there is no difference between non-terminating and stuck computations, hence soundness cannot even be expressed. The key idea is to define constructions yielding an extended version of a given arbitrary big-step semantics, where the difference is made explicit. The extended semantics are exploited in the meta-theory, notably they are necessary to show that the proof technique works. However, they remain transparent when using the proof technique, since it consists in checking three conditions on the original rules only, as we illustrate by several examples.",,,,,29th European Symposium on Programming (ESOP) held as part of the European Joint Conferences on Theory and Practice of Software (ETAPS)29th European Symposium on Programming (ESOP) held as part of the European Joint Conferences on Theory and Practice of Software (ETAPS),"JUL 02, 2020JUL 02, 2020",,ELECTR NETWORKELECTR NETWORK,1,0,0,0,0,0,1,,,0302-9743,1611-3349,978-3-030-44914-8; 978-3-030-44913-1,WOS:000681656800007,
C,"Paviotti, Marco; Cooksey, Simon; Paradis, Anouk; Wright, Daniel; Owens, Scott; Batty, Mark",,,,,"Wright, Daniel/0000-0001-7404-2367; Paviotti, Marco/0000-0002-1513-0807","Muller, P",,Modular Relaxed Dependencies in Weak Memory Concurrency,,,,,,,,PROGRAMMING LANGUAGES AND SYSTEMS ( ESOP 2020): 29TH EUROPEAN SYMPOSIUM ON PROGRAMMING,,Lecture Notes in Computer Science,,12075,,,,599,625,,10.1007/978-3-030-44914-8_22,,,,2020,2020,"We present a denotational semantics for weak memory concurrency that avoids thin-air reads, provides data-race free programs with sequentially consistent semantics (DRF-SC), and supports a compositional refinement relation for validating optimisations. Our semantics identifies false program dependencies that might be removed by compiler optimisation, and leaves in place just the dependencies necessary to rule out thin-air reads. We show that our dependency calculation can be used to rule out thin-air reads in any axiomatic concurrency model, in particular C++. We present a tool that automatically evaluates litmus tests, show that we can augment C++ to fix the thin-air problem, and we prove that our augmentation is compatible with the previously used compilation mappings over key processor architectures. We argue that our dependency calculation offers a practical route to fixing the longstanding problem of thin-air reads in the C++ specification.",,,,,29th European Symposium on Programming (ESOP) held as part of the European Joint Conferences on Theory and Practice of Software (ETAPS)29th European Symposium on Programming (ESOP) held as part of the European Joint Conferences on Theory and Practice of Software (ETAPS),"JUL 02, 2020JUL 02, 2020",,ELECTR NETWORKELECTR NETWORK,10,0,0,0,0,0,10,,,0302-9743,1611-3349,978-3-030-44914-8; 978-3-030-44913-1,WOS:000681656800022,
J,"Czajka, Lukasz",,,,,,,,A NEW COINDUCTIVE CONFLUENCE PROOF FOR INFINITARY LAMBDA CALCULUS,,,,,,,,LOGICAL METHODS IN COMPUTER SCIENCE,,,,16,1,,,,,31,10.23638/LMCS-16(1:31)2020,,,,2020,2020,"We present a new and formal coinductive proof of confluence and normalisation of Bohm reduction in infinitary lambda calculus. The proof is simpler than previous proofs of this result. The technique of the proof is new, i.e., it is not merely a coinductive reformulation of any earlier proofs. We formalised the proof in the Coq proof assistant.",,,,,,,,,0,0,0,0,0,0,0,,,1860-5974,,,WOS:000523360600021,
J,"Dagnino, Francesco",,,,,,,,COAXIOMS: FLEXIBLE COINDUCTIVE DEFINITIONS BY INFERENCE SYSTEMS,,,,,,,,LOGICAL METHODS IN COMPUTER SCIENCE,,,,15,1,,,,,26,10.23638/LMCS-15(1:26)2019,,,,2019,2019,"We introduce a generalized notion of inference system to support more flexible interpretations of recursive definitions. Besides axioms and inference rules with the usual meaning, we allow also coaxioms, which are, intuitively, axioms which can only be applied at infinite depth in a proof tree. Coaxioms allow us to interpret recursive definitions as fixed points which arc not necessarily the least, nor the greatest one, whose existence is guaranteed by a smooth extension of classical results. This notion nicely subsumes standard inference systems and their inductive and coinductive interpretation, thus allowing formal reasoning in cases where the inductive and coinductive interpretation do not provide the intended meaning, but are rather mixed together.",,,,,,,,,6,0,0,0,0,0,6,,,1860-5974,,,WOS:000463358400035,
C,"Mizuno, Masayuki; Sumii, Eijiro",,,,,,"Lin, AW",,Formal Verifications of Call-by-Need and Call-by-Name Evaluations with Mutual Recursion,,,,,,,,"PROGRAMMING LANGUAGES AND SYSTEMS, APLAS 2019",,Lecture Notes in Computer Science,,11893,,,,181,201,,10.1007/978-3-030-34175-6_10,,,,2019,2019,"We present new proofs-formalized in the Coq proof assistant-of the correspondence among call-by-need and (various definitions of) call-by-name evaluations of lambda-calculus with mutually recursive bindings.For non-strict languages, the equivalence between high-level specifications (call-by-name) and typical implementations (call-by-need) is of foundational interest. A particular milestone is Launchbury's natural semantics of call-by-need evaluation and proof of its adequacy with respect to call-by-name denotational semantics, which are recently formalized in Isabelle/HOL by Breitner (2018). Equational theory by Ariola et al. is another well-known formalization of call-by-need. Mutual recursion is especially challenging for their theory: reduction is complicated by the traversal of dependency (the need relation), and the correspondence of call-by-name and call-by-need reductions becomes non-trivial, requiring sophisticated structures such as graphs or infinite trees.In this paper, we give arguably simpler proofs solely based on (finite) terms and operational semantics, which are easier to handle for proof assistants (Coq in our case). Our proofs can be summarized as follows: (1) we prove the equivalence between Launchbury's call-by-need semantics and heap-based call-by-name natural semantics, where we define a sufficiently (but not too) general correspondence between the two heaps, and (2) we also show the correspondence among three styles of call-by-name semantics: (i) the natural semantics used in (1); (ii) closure-based natural semantics that informally corresponds to Launchbury's denotational semantics; and (iii) conventional substitution-based semantics.",,,,,17th Asian Symposium on Programming Languages and Systems (APLAS)17th Asian Symposium on Programming Languages and Systems (APLAS),"DEC 01-04, 2019DEC 01-04, 2019",,"Bali, INDONESIABali, INDONESIA",1,0,0,0,0,0,1,,,0302-9743,1611-3349,978-3-030-34175-6; 978-3-030-34174-9,WOS:000611530200010,
C,"Vesely, Ferdinand; Fisher, Kathleen",,,,,,"Caires, L",,One Step at a Time A Functional Derivation of Small-Step Evaluators from Big-Step Counterparts,,,,,,,,"PROGRAMMING LANGUAGES AND SYSTEMS, ESOP 2019: 28TH EUROPEAN SYMPOSIUM ON PROGRAMMING",,Lecture Notes in Computer Science,,11423,,,,205,231,,10.1007/978-3-030-17184-1_8,,,,2019,2019,"Big-step and small-step are two popular flavors of operational semantics. Big-step is often seen as a more natural transcription of informal descriptions, as well as being more convenient for some applications such as interpreter generation or optimization verification. Small-step allows reasoning about non-terminating computations, concurrency and interactions. It is also generally preferred for reasoning about type systems. Instead of having to manually specify equivalent semantics in both styles for different applications, it would be useful to choose one and derive the other in a systematic or, preferably, automatic way.Transformations of small-step semantics into big-step have been investigated in various forms by Danvy and others. However, it appears that a corresponding transformation from big-step to small-step semantics has not had the same attention. We present a fully automated transformation that maps big-step evaluators written in direct style to their small-step counterparts. Many of the steps in the transformation, which include CPS-conversion, defunctionalisation, and various continuation manipulations, mirror those used by Danvy and his co-authors. For many standard languages, including those with either call-by-value or call-by-need and those with state, the transformation produces small-step semantics that are close in style to handwritten ones. We evaluate the applicability and correctness of the approach on 20 languages with a range of features.",,,,,28th European Symposium on Programming (ESOP) Held as Part of the European Joint Conferences on Theory and Practice of Software (ETAPS)28th European Symposium on Programming (ESOP) Held as Part of the European Joint Conferences on Theory and Practice of Software (ETAPS),"APR 06-11, 2019APR 06-11, 2019",,"Prague, CZECH REPUBLICPrague, CZECH REPUBLIC",0,0,0,0,0,0,0,,,0302-9743,1611-3349,978-3-030-17184-1; 978-3-030-17183-4,WOS:000681669300008,
C,"Allombert, Victor; Gava, Frederic; Tesson, Julien",,,IEEE,,"GAVA, FREDERIC/0000-0001-5452-3809",,,A formal semantics of the MULTI-ML language,,,,,,,,2018 17TH INTERNATIONAL SYMPOSIUM ON PARALLEL AND DISTRIBUTED COMPUTING (ISPDC),,International Symposium on Parallel and Distributed Computing,,,,,,180,187,,10.1109/ISPDC2018.2018.00033,,,,2018,2018,"In the context of high performance computing, it is important to avoid indeterminism and dead-locks. MULTI-ML is a functional parallel programming language a la ML, designed to program hierarchical architectures in a structured way. It is based of the MULTI-BSP bridging model. To ensure that a program cannot go wrong, we first need to define how a program goes. To do so, we propose a formal operational semantics of the MULTI-ML language to ensure the properties of the MULTI-BSP model. We first describe a core-language and then introduce the big step's semantics evaluation rules. Then, we propose a set of evaluation rules that describe the behaviour of the MULTI-ML language. The memory model is also precisely defined, as the MULTI-BSP model deals with multiple level of nested memories.",,,,,17th Annual International Symposium on Parallel and Distributed Computing (ISPDC)17th Annual International Symposium on Parallel and Distributed Computing (ISPDC),"JUN 25-28, 2018JUN 25-28, 2018",Univ Appl Sci & Arts Western Switzerland; Univ GenevaUniv Appl Sci & Arts Western Switzerland; Univ Geneva,"Geneva, SWITZERLANDGeneva, SWITZERLAND",2,0,0,0,0,0,2,,,2379-5352,,978-1-5386-5330-2,WOS:000447280800024,
J,"Ancona, Davide; Dagnino, Francesco; Zucca, Elena",,,,,,,,Reasoning on Divergent Computations with Coaxioms,,,,,,,,PROCEEDINGS OF THE ACM ON PROGRAMMING LANGUAGES-PACMPL,,,,1,,,,,,81,10.1145/3133905,,,,OCT 2017,2017,"Coaxioms have been recently introduced to enhance the expressive power of inference systems, by supporting interpretations which are neither purely inductive, nor coinductive. This paper proposes a novel approach based on coaxioms to capture divergence in semantic definitions by allowing inductive and coinductive semantic rules to be merged together for defining a unique semantic judgment. In particular, coinduction is used to derive a special result which models divergence. In this way, divergent, terminating, and stuck computations can be properly distinguished even in semantic definitions where this is typically difficult, as in big-step style. We show how the proposed approach can be applied to several languages; in particular, we first illustrate it on the paradigmatic example of the lambda-calculus, then show how it can be adopted for defining the big-step semantics of a simple imperative Java-like language. We provide proof techniques to show classical results, including equivalence with small-step semantics, and type soundness for typed versions of both languages.",,,,,,,,,2,0,0,0,0,0,2,,,,2475-1421,,WOS:000688014000037,
J,"Allombert, V.; Gava, F.; Tesson, J.",,,,,"GAVA, FREDERIC/0000-0001-5452-3809",,,Multi-ML: Programming Multi-BSP Algorithms in ML,,,,,,,,INTERNATIONAL JOURNAL OF PARALLEL PROGRAMMING,,,,45,2,SI,,340,361,,10.1007/s10766-016-0417-6,,,,APR 2017,2017,"bsp is a bridging model between abstract execution and concrete parallel systems. Structure and abstraction brought by bsp allow to have portable parallel programs with scalable performance predictions, without dealing with low-level details of architectures. In the past, we designed bsml for programming bsp algorithms in ml. However, the simplicity of the bsp model does not fit the complexity of today's hierarchical architectures such as clusters of machines with multiple multi-core processors. The multi-bsp model is an extension of the bsp model which brings a tree-based view of nested components of hierarchical architectures. To program multi-bsp algorithms in ml, we propose the multi-ml language as an extension of bsml where a specific kind of recursion is used to go through a hierarchy of computing nodes. We define a formal semantics of the language and present preliminary experiments which show performance improvements with respect to bsml.",,,,,,,,,6,0,0,0,0,0,6,,,0885-7458,1573-7640,,WOS:000397811200009,
J,"Poulsen, Casper Bach; Mosses, Peter D.",,,,"Mosses, Peter/A-8206-2019","Mosses, Peter/0000-0002-5826-7520; Bach Poulsen, Casper/0000-0003-0622-7639",,,Flag-based big-step semantics,,,,,,,,JOURNAL OF LOGICAL AND ALGEBRAIC METHODS IN PROGRAMMING,,,,88,,,,174,190,,10.1016/j.jlamp.2016.05.001,,,,APR 2017,2017,"Structural operational semantic specifications come in different styles: small-step and big-step. A problem with the big-step style is that specifying divergence and abrupt termination gives rise to annoying duplication. We present a novel approach to representing divergence and abrupt termination in big-step semantics using status flags. This avoids the duplication problem, and uses fewer rules and premises for representing divergence than previous approaches in the literature. (C) 2016 Elsevier Inc. All rights reserved.",,,,,26th Nordic Workshop on Programming Theory (NWPT)26th Nordic Workshop on Programming Theory (NWPT),"OCT 29-31, 2014OCT 29-31, 2014",,"Halmstad Univ, Halmstad, SWEDENHalmstad Univ, Halmstad, SWEDEN",5,0,0,0,0,0,5,,,2352-2208,,,WOS:000396972200008,
J,"Giannini, Paola; Shaqiri, Albert",,,,,"Giannini, Paola/0000-0003-2239-9529",,,A Provably Correct Compilation of Functional Languages into Scripting Languags,,,,,,,,SCIENTIFIC ANNALS OF COMPUTER SCIENCE,,,,27,1,,,19,76,,10.7561/SACS.2017.1.19,,,,2017,2017,"In this paper we consider the problem of translating core F#, a typed functional language including mutable variables and exception handling, into scripting languages such as JavaScript or Python. In previous work, we abstracted the most significant characteristics of scripting languages in an intermediate language (IL for short). IL is a block-structured imperative language in which a definition of a name does not have to statically precede its use. We define a big-step operational semantics for core F# and for IL and formalise the translation of F# expressions into IL. The main contribution of the paper is the proof of correctness of the given translation, which is done by showing that the evaluation of a well-typed F# program converges to a primitive value if and only if the evaluation of its translation into IL converges to the same value.",,,,,,,,,0,0,0,0,0,0,0,,,1843-8121,,,WOS:000418749700002,
C,"Amin, Nada; Rompf, Tiark",,,,,"Rompf, Tiark/0000-0002-2068-3238",,,Type Soundness Proofs with Definitional Interpreters,,,,,,,,ACM SIGPLAN NOTICES,,,,52,1,,,666,679,,10.1145/3093333.3009866,,,,JAN 2017,2017,"While type soundness proofs are taught in every graduate PL class, the gap between realistic languages and what is accessible to formal proofs is large. In the case of Scala, it has been shown that its formal model, the Dependent Object Types (DOT) calculus, cannot simultaneously support key metatheoretic properties such as environment narrowing and subtyping transitivity, which are usually required for a type soundness proof. Moreover, Scala and many other realistic languages lack a general substitution property.The first contribution of this paper is to demonstrate how type soundness proofs for advanced, polymorphic, type systems can be carried out with an operational semantics based on high-level, definitional interpreters, implemented in Coq. We present the first mechanized soundness proofs in this style for System F-<: and several extensions, including mutable references. Our proofs use only straightforward induction, which is significant, as the combination of big-step semantics, mutable references, and polymorphism is commonly believed to require coinductive proof techniques.The second main contribution of this paper is to show how DOT-like calculi emerge from straightforward generalizations of the operational aspects of F-< :, exposing a rich design space of calculi with path-dependent types inbetween System F and DOT, which we dub the System D Square.By working directly on the target language, definitional interpreters can focus the design space and expose the invariants that actually matter at runtime. Looking at such runtime invariants is an exciting new avenue for type system design.",,,,,44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL)44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL),"JAN 18-20, 2017JAN 18-20, 2017",ACM SIGPLANACM SIGPLAN,"Paris, FRANCEParis, FRANCE",26,0,0,0,0,0,26,,,0362-1340,1558-1160,,WOS:000408311200050,
C,"Ancona, Davide; Dagnino, Francesco; Zucca, Elena",,,,,,"Yang, H",,Generalizing Inference Systems by Coaxioms,,,,,,,,PROGRAMMING LANGUAGES AND SYSTEMS (ESOP 2017): 26TH EUROPEAN SYMPOSIUM ON PROGRAMMING,,Lecture Notes in Computer Science,,10201,,,,29,55,,10.1007/978-3-662-54434-1_2,,,,2017,2017,"We introduce a generalized notion of inference system to support structural recursion on non well-founded datatypes. Besides axioms and inference rules with the usual meaning, a generalized inference system allows coaxioms, which are, intuitively, axioms which can only be applied at infinite depth in a proof tree. This notion nicely subsumes standard inference systems and their inductive and coinductive interpretation, while providing more flexibility. Indeed, the classical results on the existence and constructive characterization of least and greatest fixed points can be extended to our generalized framework, interpreting recursive definitions as fixed points which are not necessarily the least, nor the greatest one. This allows formal reasoning in cases where the inductive and coinductive interpretation do not provide the intended meaning, or are mixed together.",,,,,26th European Symposium on Programming (ESOP) Held as Part of the European Joint Conferences on Theory and Practice of Software (ETAPS)26th European Symposium on Programming (ESOP) Held as Part of the European Joint Conferences on Theory and Practice of Software (ETAPS),"APR 22-29, 2017APR 22-29, 2017",,"Uppsala, SWEDENUppsala, SWEDEN",9,0,0,0,0,0,9,,,0302-9743,1611-3349,978-3-662-54434-1; 978-3-662-54433-4,WOS:000681702400002,
J,"Ancona, Davide; Corradi, Andrea",,,,,,,,Semantic Subtyping for Imperative Object-Oriented Languages,,,,,,,,ACM SIGPLAN NOTICES,,,,51,10,,,568,587,,10.1145/3022671.2983992,,,,OCT 2016,2016,"Semantic subtyping is an approach for defining sound and complete procedures to decide subtyping for expressive types, including union and intersection types; although it has been exploited especially in functional languages for XML based programming, recently it has been partially investigated in the context of object-oriented languages, and a sound and complete subtyping algorithm has been proposed for record types, but restricted to immutable fields, with union and recursive types interpreted coinductively to support cyclic objects.In this work we address the problem of studying semantic subtyping for imperative object-oriented languages, where fields can be mutable; in particular, we add read/write field annotations to record types, and, besides union, we consider intersection types as well, while maintaining coinductive interpretation of recursive types. In this way, we get a richer notion of type with a flexible subtyping relation, able to express a variety of type invariants useful for enforcing static guarantees for mutable objects.The addition of these features radically changes the definition of subtyping, and, hence, the corresponding decision procedure, and surprisingly invalidates some subtyping laws that hold in the functional setting.We propose an intuitive model where mutable record values contain type information to specify the values that can be correctly stored in fields. Such a model, and the corresponding subtyping rules, require particular care to avoid circularity between coinductive judgments and their negations which, by duality, have to be interpreted inductively.A sound and complete subtyping algorithm is provided, together with a prototype implementation.",,,,,"ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)","NOV 02-04, 2016NOV 02-04, 2016",Assoc Comp Machinery; ACM SIGPLANAssoc Comp Machinery; ACM SIGPLAN,"Amsterdam, NETHERLANDSAmsterdam, NETHERLANDS",7,0,0,0,0,0,7,,,0362-1340,1558-1160,,WOS:000393581000033,
J,"Rodriguez, Leonardo; Pagano, Miguel; Fridlender, Daniel",,,,,,,,Proving Correctness of a Compiler Using Step-indexed Logical Relations,,,,,,,,ELECTRONIC NOTES IN THEORETICAL COMPUTER SCIENCE,,,,323,,,,197,214,,10.1016/j.entcs.2016.06.013,,,,JUL 11 2016,2016,"In this paper we prove the correctness of a compiler for a call-by-name language using step-indexed logical relations and biorthogonality. The source language is an extension of the simply typed lambda-calculus with recursion, and the target language is an extension of the Krivine abstract machine. We formalized the proof in the Coq proof assistant.",,,,,,,,,3,0,0,0,0,0,3,,,1571-0661,,,WOS:000384406400013,
C,"Owens, Scott; Myreen, Magnus O.; Kumar, Ramana; Tan, Yong Kiam",,,,,"Owens, Scott/0000-0002-7437-4780","Thiemann, P",,Functional Big-Step Semantics,,,,,,,,PROGRAMMING LANGUAGES AND SYSTEMS (ESOP 2016),,Lecture Notes in Computer Science,,9632,,,,589,615,,10.1007/978-3-662-49498-1_23,,,,2016,2016,"When doing an interactive proof about a piece of software, it is important that the underlying programming language's semantics does not make the proof unnecessarily difficult or unwieldy. Both small-step and big-step semantics are commonly used, and the latter is typically given by an inductively defined relation. In this paper, we consider an alternative: using a recursive function akin to an interpreter for the language. The advantages include a better induction theorem, less duplication, accessibility to ordinary functional programmers, and the ease of doing symbolic simulation in proofs via rewriting. We believe that this style of semantics is well suited for compiler verification, including proofs of divergence preservation. We do not claim the invention of this style of semantics: our contribution here is to clarify its value, and to explain how it supports several language features that might appear to require a relational or small-step approach. We illustrate the technique on a simple imperative language with C-like for-loops and a break statement, and compare it to a variety of other approaches. We also provide ML and lambda-calculus based examples to illustrate its generality.",,,,,25th European Symposium on Programming (ESOP) Held as Part of the European Joint Conferences on Theory and Practice of Software (ETAPS)25th European Symposium on Programming (ESOP) Held as Part of the European Joint Conferences on Theory and Practice of Software (ETAPS),"APR 03-07, 2016APR 03-07, 2016",,"Eindhoven, NETHERLANDSEindhoven, NETHERLANDS",35,0,0,0,0,0,35,,,0302-9743,1611-3349,978-3-662-49498-1; 978-3-662-49497-4,WOS:000401936100023,
C,"Cheney, James; Momigliano, Alberto; Pessina, Matteo",,,,"Momigliano, Alberto/M-6152-2017","Momigliano, Alberto/0000-0003-0942-4777","Aichernig, BK; Furia, CA",,Advances in Property-Based Testing for alpha Prolog,,,,,,,,"TESTS AND PROOFS, TAP 2016",,Lecture Notes in Computer Science,,9762,,,,37,56,,10.1007/978-3-319-41135-4_3,,,,2016,2016,"alpha Check is a light-weight property-based testing tool built on top of alpha Prolog, a logic programming language based on nominal logic. alpha Prolog is particularly suited to the validation of the meta-theory of formal systems, for example correctness of compiler translations involving name-binding, alpha-equivalence and capture-avoiding substitution. In this paper we describe an alternative to the negation elimination algorithm underlying alpha Check that substantially improves its effectiveness. To substantiate this claim we compare the checker performances w.r.t. two of its main competitors in the logical framework niche, namely the QuickCheck/Nitpick combination offered by Isabelle/HOL and the random testing facility in PLT-Redex.",,,,,10th International Conference on Tests and Proofs (TAP) held as Part of Conference on Software Technologies - Applications and Foundations (STAF)10th International Conference on Tests and Proofs (TAP) held as Part of Conference on Software Technologies - Applications and Foundations (STAF),"JUL 05-07, 2016JUL 05-07, 2016",,"TU Wien, Vienna, AUSTRIATU Wien, Vienna, AUSTRIA",4,0,0,0,0,0,4,,,0302-9743,1611-3349,978-3-319-41135-4; 978-3-319-41134-7,WOS:000386324100003,
J,"Danner, Norman; Licata, Daniel R.; Ramyaa, Ramyaa",,,,,,,,Denotational Cost Semantics for Functional Languages with Inductive Types,,,,,,,,ACM SIGPLAN NOTICES,,,,50,9,,,140,151,,10.1145/2784731.2784749,,,,SEP 2015,2015,"A central method for analyzing the asymptotic complexity of a functional program is to extract and then solve a recurrence that expresses evaluation cost in terms of input size. The relevant notion of input size is often specific to a datatype, with measures including the length of a list, the maximum element in a list, and the height of a tree. In this work, we give a formal account of the extraction of cost and size recurrences from higher-order functional programs over inductive datatypes. Our approach allows a wide range of programmer-specified notions of size, and ensures that the extracted recurrences correctly predict evaluation cost. To extract a recurrence from a program, we first make costs explicit by applying a monadic translation from the source language to a complexity language, and then abstract datatype values as sizes. Size abstraction can be done semantically, working in models of the complexity language, or syntactically, by adding rules to a preorder judgement. We give several different models of the complexity language, which support different notions of size. Additionally, we prove by a logical relations argument that recurrences extracted by this process are upper bounds for evaluation cost; the proof is entirely syntactic and therefore applies to all of the models we consider.",,,,,20th ACM SIGPLAN International Conference on Functional Programming (ICFP)20th ACM SIGPLAN International Conference on Functional Programming (ICFP),"AUG 31-SEP 02, 2015AUG 31-SEP 02, 2015",ACM SIGPLANACM SIGPLAN,"Vancouver, CANADAVancouver, CANADA",2,0,0,0,0,0,2,,,0362-1340,1558-1160,,WOS:000367255800013,
C,"Danner, Norman; Licata, Daniel R.; Ramyaa, Ramyaa",,,,,,"Fisher, K; Reppy, J",,Denotational Cost Semantics for Functional Languages with Inductive Types,,,,,,,,PROCEEDINGS OF THE 20TH ACM SIGPLAN INTERNATIONAL CONFERENCE ON FUNCTIONAL PROGRAMMING (ICFP'15),,,,,,,,140,151,,10.1145/2784731.2784749,,,,2015,2015,"A central method for analyzing the asymptotic complexity of a functional program is to extract and then solve a recurrence that expresses evaluation cost in terms of input size. The relevant notion of input size is often specific to a datatype, with measures including the length of a list, the maximum element in a list, and the height of a tree. In this work, we give a formal account of the extraction of cost and size recurrences from higher-order functional programs over inductive datatypes. Our approach allows a wide range of programmer-specified notions of size, and ensures that the extracted recurrences correctly predict evaluation cost. To extract a recurrence from a program, we first make costs explicit by applying a monadic translation from the source language to a complexity language, and then abstract datatype values as sizes. Size abstraction can be done semantically, working in models of the complexity language, or syntactically, by adding rules to a preorder judgement. We give several different models of the complexity language, which support different notions of size. Additionally, we prove by a logical relations argument that recurrences extracted by this process are upper bounds for evaluation cost; the proof is entirely syntactic and therefore applies to all of the models we consider.",,,,,20th ACM SIGPLAN International Conference on Functional Programming (ICFP)20th ACM SIGPLAN International Conference on Functional Programming (ICFP),"AUG 31-SEP 02, 2015AUG 31-SEP 02, 2015",ACM SIGPLAN; Assoc Comp MachineryACM SIGPLAN; Assoc Comp Machinery,"Vancouver, CANADAVancouver, CANADA",25,0,0,0,0,0,23,,,,,978-1-4503-3669-7,WOS:000382171900013,
J,"Nakata, Keiko; Uustalu, Tarmo",,,,"Uustalu, Tarmo/I-1242-2015","Uustalu, Tarmo/0000-0002-1297-0579",,,A HOARE LOGIC FOR THE COINDUCTIVE TRACE-BASED BIG-STEP SEMANTICS OF WHILE,,,,,,,,LOGICAL METHODS IN COMPUTER SCIENCE,,,,11,1,,,,,1,10.2168/LMCS-11(1:1)2015,,,,2015,2015,"In search for a foundational framework for reasoning about observable behavior of programs that may not terminate, we have previously devised a trace-based big-step semantics for While. In this semantics, both traces and evaluation (relating initial states of program runs to traces they produce) are defined coinductively. On terminating runs, this semantics agrees with the standard inductive state-based semantics. Here we present a Hoare logic counterpart of our coinductive trace-based semantics and prove it sound and complete. Our logic subsumes the standard partial-correctness state-based Hoare logic as well as the total-correctness variation: they are embeddable. In the converse direction, projections can be constructed: a derivation of a Hoare triple in our trace-based logic can be translated into a derivation iii the state-based logic of a translated, weaker Hoare triple. Since we work with a constructive underlying logic, the range of program properties we can reason about has a fine structure; in particular, we can distinguish between termination and nondivergence, e.g., unbounded classically total search fails to be terminating, but is nonetheless nondivergent. Our metatheorv is entirely constructive as well, and we have formalized it in Coq.",,,,,,,,,6,0,0,0,0,0,6,,,1860-5974,,,WOS:000353193000009,
C,"Ramananandro, Tahina; Shao, Zhong; Weng, Shu-Chun; Koenig, Jeremie; Fu, Yuchen",,,Assoc Comp Machinery,,"Shao, Zhong/0000-0001-8184-7649; Koenig, Jeremie/0000-0002-3168-5925",,,A Compositional Semantics for Verified Separate Compilation and Linking,,,,,,,,CPP'15: PROCEEDINGS OF THE 2015 ACM CONFERENCE ON CERTIFIED PROGRAMS AND PROOFS,,,,,,,,3,14,,10.1145/2676724.2693167,,,,2015,2015,"Recent ground-breaking efforts such as CompCert have made a convincing case that mechanized verification of the compiler correctness for realistic C programs is both viable and practical. Unfortunately, existing verified compilers can only handle whole programs-this severely limits their applicability and prevents the linking of verified C programs with verified external libraries. In this paper, we present a novel compositional semantics for reasoning about open modules and for supporting verified separate compilation and linking. More specifically, we replace external function calls with explicit events in the behavioral semantics. We then develop a verified linking operator that makes lazy substitutions on (potentially reacting) behaviors by replacing each external function call event with a behavior simulating the requested function. Finally, we show how our new semantics can be applied to build a refinement infrastructure that supports both vertical composition and horizontal composition.",,,,,ACM SIGPLAN Conference on Certified Programs and Proofs (CPP)ACM SIGPLAN Conference on Certified Programs and Proofs (CPP),"JAN 13-14, 2015JAN 13-14, 2015",Assoc Comp Machinery; ACM SIGPLANAssoc Comp Machinery; ACM SIGPLAN,"Mumbai, INDIAMumbai, INDIA",13,0,0,0,1,0,13,,,,,978-1-4503-3296-5,WOS:000491863900002,
C,"Bodin, Martin; Jensen, Thomas; Schmitt, Alan",,,Assoc Comp Machinery,,"Bodin, Martin/0000-0003-3588-3782",,,Certified Abstract Interpretation with Pretty-Big-Step Semantics,,,,,,,,CPP'15: PROCEEDINGS OF THE 2015 ACM CONFERENCE ON CERTIFIED PROGRAMS AND PROOFS,,,,,,,,28,39,,10.1145/2676724.2693174,,,,2015,2015,"This paper describes an investigation into developing certified abstract interpreters from big-step semantics using the Coq proof assistant. We base our approach on Schmidt's abstract interpretation principles for natural semantics, and use a pretty-big-step (PBS) semantics, a semantic format proposed by Chargueraud. We propose a systematic representation of the PBS format and implement it in Coq. We then show how the semantic rules can be abstracted in a methodical fashion, independently of the chosen abstract domain, to produce a set of abstract inference rules that specify an abstract interpreter. We prove the correctness of the abstract interpreter in Coq once and for all, under the assumption that abstract operations faithfully respect the concrete ones. We finally show how to define correct-by-construction analyses: their correction amounts to proving they belong to the abstract semantics.",,,,,ACM SIGPLAN Conference on Certified Programs and Proofs (CPP)ACM SIGPLAN Conference on Certified Programs and Proofs (CPP),"JAN 13-14, 2015JAN 13-14, 2015",Assoc Comp Machinery; ACM SIGPLANAssoc Comp Machinery; ACM SIGPLAN,"Mumbai, INDIAMumbai, INDIA",4,0,0,0,0,0,4,,,,,978-1-4503-3296-5,WOS:000491863900004,
C,"Poulsen, Casper Bach; Mosses, Peter D.; Torrini, Paolo",,,ACM,"Mosses, Peter/A-8206-2019","Mosses, Peter/0000-0002-5826-7520; Bach Poulsen, Casper/0000-0003-0622-7639",,,Imperative Polymorphism by Store-Based Types as Abstract Interpretations,,,,,,,,PROCEEDINGS OF THE 2015 ACM SIGPLAN WORKSHOP ON PARTIAL EVALUATION AND PROGRAM MANIPULATION (PEPM'15),,,,,,,,3,8,,10.1145/2678015.2682545,,,,2015,2015,"Dealing with polymorphism in the presence of imperative features is a long-standing open problem for Hindley-Milner type systems. A widely adopted approach is the value restriction, which inhibits polymorphic generalisation and unfairly rejects various programs that cannot go wrong. We consider abstract interpretation as a tool for constructing safe and precise type systems, and investigate how to derive store-based types by abstract interpretation. We propose store-based types as a type discipline that holds potential for interesting and flexible alternatives to the value restriction.",,,,,ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation (PEPM)ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation (PEPM),"JAN 13-14, 2015JAN 13-14, 2015",Assoc Comp Machinery; ACM SIGPLANAssoc Comp Machinery; ACM SIGPLAN,"Mumbai, INDIAMumbai, INDIA",1,0,0,0,0,0,1,,,,,978-1-4503-3297-2,WOS:000461460400002,
J,"Wang, Peng; Cuellar, Santiago; Chlipala, Adam",,,,,,,,Compiler Verification Meets Cross-Language Linking via Data Abstraction,,,,,,,,ACM SIGPLAN NOTICES,,,,49,10,,,675,690,,10.1145/2714064.2660201,,,,OCT 2014,2014,"Many real programs are written in multiple different programming languages, and supporting this pattern creates challenges for formal compiler verification. We describe our Coq verification of a compiler for a high-level language, such that the compiler correctness theorem allows us to derive partial-correctness Hoare-logic theorems for programs built by linking the assembly code output by our compiler and assembly code produced by other means. Our compiler supports such tricky features as storable cross-language function pointers, without giving up the usual benefits of being able to verify different compiler phases (including, in our case, two classic optimizations) independently. The key technical innovation is a mixed operational and axiomatic semantics for the source language, with a built-in notion of abstract data types, such that compiled code interfaces with other languages only through axiomatically specified methods that mutate encapsulated private data, represented in whatever formats are most natural for those languages.",,,,,2014 ACM International Conference on Object-Oriented-Programming-Systems-Languages-and-Applications (OOPSLA 14)2014 ACM International Conference on Object-Oriented-Programming-Systems-Languages-and-Applications (OOPSLA 14),"OCT 20-24, 2014OCT 20-24, 2014",,"Portland, ORPortland, OR",4,0,0,0,0,0,4,,,0362-1340,1558-1160,,WOS:000348907400038,
C,"Ancona, Davide; Corradi, Andrea",,,,,,"Jones, R",,Sound and Complete Subtyping between Coinductive Types for Object-Oriented Languages,,,,,,,,ECOOP 2014 - OBJECT-ORIENTED PROGRAMMING,,Lecture Notes in Computer Science,,8586,,,,282,307,,,,,,2014,2014,"Structural subtyping is an important notion for effective static type analysis; it can be defined either axiomatically by a collection of subtyping rules, or by means of set inclusion between type interpretations, following the more intuitive approach of semantic subtyping, which allows simpler proofs of the expected properties of the subtyping relation.In object-oriented programming, recursive types are typically interpreted inductively; however, cyclic objects can be represented more precisely by coinductive types.We study semantic subtyping between coinductive types with records and unions, which are particularly interesting for object-oriented programming, and develop and implement a sound and complete top-down direct and effective algorithm for deciding it. To our knowledge, this is the first proposal for a sound and complete top-down direct algorithm for semantic subtyping between coinductive types.",,,,,28th European Conference on Object-Oriented Programming (ECOOP)28th European Conference on Object-Oriented Programming (ECOOP),"JUL 28-AUG 01, 2014JUL 28-AUG 01, 2014",Google; Orable Labs; Samsung Res Amer; Typesafe; IBM Res; Uppsala Univ; Univ Kent; Assoc Internationale Technologies Objets; ACM SIGPLAN; ACM SIGSOFTGoogle; Orable Labs; Samsung Res Amer; Typesafe; IBM Res; Uppsala Univ; Univ Kent; Assoc Internationale Technologies Objets; ACM SIGPLAN; ACM SIGSOFT,"Uppsala, SWEDENUppsala, SWEDEN",9,0,0,0,0,0,9,,,0302-9743,1611-3349,978-3-662-44202-9; 978-3-662-44201-2,WOS:000360146400012,
J,"Bartoletti, Massimo; Cimoli, Tiziana; Pinna, G. Michele; Zunino, Roberto",,,,,"Cimoli, Tiziana/0000-0002-8591-4527; Bartoletti, Massimo/0000-0003-3796-9774; PINNA, GIOVANNI MICHELE/0000-0001-8911-1580",,,Circular Causality in Event Structures,,,,,,,,FUNDAMENTA INFORMATICAE,,,,134,3-4,,,219,259,,10.3233/FI-2014-1101,,,,2014,2014,"We propose a model of events with circular causality, in the form of a conservative extension of Winskel's event structures. We study the relations between this new kind of event structures and Propositional Contract Logic. Provable atoms in the logic correspond to reachable events in our event structures. Furthermore, we show a correspondence between the configurations of this new brand of event structures and the proofs in a fragment of Propositional Contract Logic.",,,,,,,,,8,0,0,0,0,0,8,,,0169-2968,1875-8681,,WOS:000345457500002,
C,"Poulsen, Casper Bach; Mosses, Peter D.",,,,"Mosses, Peter/A-8206-2019","Mosses, Peter/0000-0002-5826-7520; Bach Poulsen, Casper/0000-0003-0622-7639","Shao, Z",,Deriving Pretty-Big-Step Semantics from Small-Step Semantics,,,,,,,,PROGRAMMING LANGUAGES AND SYSTEMS,,Lecture Notes in Computer Science,,8410,,,,270,289,,,,,,2014,2014,"Big-step semantics for languages with abrupt termination and/or divergence suffer from a serious duplication problem, addressed by the novel 'pretty-big-step' style presented by Chargueraud at ESOP' 13. Such rules are less concise than corresponding small-step rules, but they have the same advantages as big-step rules for program correctness proofs. Here, we show how to automatically derive pretty-big-step rules directly from small-step rules by 'refocusing'. This gives the best of both worlds: we only need to write the relatively concise small-step specifications, but our reasoning can be big-step as well as small-step. The use of strictness annotations to derive small-step congruence rules gives further conciseness.",,,,,23rd European Symposium on Programming (ESOP)23rd European Symposium on Programming (ESOP),"APR 05-13, 2014APR 05-13, 2014",,"Grenoble, FRANCEGrenoble, FRANCE",7,0,0,0,0,0,7,,,0302-9743,,978-3-642-54833-8; 978-3-642-54832-1,WOS:000342811600015,
C,"Koskinen, Eric; Terauchi, Tachio",,,ACM,,,,,Local Temporal Reasoning,,,,,,,,PROCEEDINGS OF THE JOINT MEETING OF THE TWENTY-THIRD EACSL ANNUAL CONFERENCE ON COMPUTER SCIENCE LOGIC (CSL) AND THE TWENTY-NINTH ANNUAL ACM/IEEE SYMPOSIUM ON LOGIC IN COMPUTER SCIENCE (LICS),,IEEE Symposium on Logic in Computer Science,,,,,,,,,10.1145/2603088.2603138,,,,2014,2014,"We present the first method for reasoning about temporal logic properties of higher-order, infinite-data programs. By distinguishing between the finite traces and infinite traces in the specification, we obtain rules that permit us to reason about the temporal behavior of program parts via a type-and-effect system, which is then able to compose these facts together to prove the overall target property of the program. The type system alone is strong enough to derive many temporal safety properties using refinement types and temporal effects. We also show how existing techniques can be used as oracles to provide liveness information (e.g. termination) about program parts and that the type-and-effect system can combine this information with temporal safety information to derive nontrivial temporal properties. Our work has application toward verification of higher-order software, as well as modular strategies for procedural programs.",,,,,Joint Meeting of the 23rd EACSL Annual Conference on Computer Science Logic (CSL) / 29th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)Joint Meeting of the 23rd EACSL Annual Conference on Computer Science Logic (CSL) / 29th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS),"JUL 09-24, 2014JUL 09-24, 2014",IEEE; ACM; EACSLIEEE; ACM; EACSL,"Vienna, AUSTRIAVienna, AUSTRIA",5,0,0,0,0,0,5,,,1043-6871,,978-1-4503-2886-9,WOS:000693915100058,
J,"Ancona, Davide",,,,,,,,Regular corecursion in Prolog,,,,,,,,COMPUTER LANGUAGES SYSTEMS & STRUCTURES,,,,39,4,SI,,142,162,,10.1016/j.cl.2013.05.001,,,,DEC 2013,2013,"Corecursion is the ability of defining a function that produces some infinite data in terms of the function and the data itself, as supported by lazy evaluation. However, in languages such as Haskell strict operations fail to terminate even on infinite regular data, that is, cyclic data.Regular corecursion is naturally supported by coinductive Prolog, an extension where predicates can be interpreted either inductively or coinductively, that has proved to be useful for formal verification, static analysis and symbolic evaluation of programs.In this paper we use the meta-programming facilities offered by Prolog to propose extensions to coinductive Prolog aiming to make regular corecursion more expressive and easier to program with.First, we propose a new interpreter to solve the problem of non-terminating failure as experienced with the standard semantics of coinduction (as supported, for instance, in SWI-Prolog). Another problem with the standard semantics is that predicates expressed in terms of existential quantification over a regular term cannot directly defined by coinduction; to this aim, we introduce finally clauses, to allow more flexibility in coinductive definitions.Then we investigate the possibility of annotating arguments of coinductive predicates, to restrict coinductive definitions to a subset of the arguments; this allows more efficient definitions, and further enhance the expressive power of coinductive Prolog.We investigate the effectiveness of such features by showing different example programs manipulating several kinds of cyclic values, ranging from automata and context free grammars to graphs and repeating decimals; the examples show how computations on cyclic values can be expressed with concise and relatively simple programs.The semantics defined by these vanilla meta-interpreters are an interesting starting point for a more mature design and implementation of coinductive Prolog. (C) 2013 Elsevier Ltd. All rights reserved.",,,,,,,,,10,0,0,0,0,0,10,,,1477-8424,1873-6866,,WOS:000328715400003,
J,"Schaefer, Max; Sridharan, Manu; Dolby, Julian; Tip, Frank",,,,,"Sridharan, Manu/0000-0001-7993-302X",,,Dynamic Determinacy Analysis,,,,,,,,ACM SIGPLAN NOTICES,,,,48,6,SI,,165,174,,10.1145/2499370.2462168,,,,JUN 2013,2013,"We present an analysis for identifying determinate variables and expressions that always have the same value at a given program point. This information can be exploited by client analyses and tools to, e. g., identify dead code or specialize uses of dynamic language constructs such as e v a l, replacing them with equivalent static constructs. Our analysis is completely dynamic and only needs to observe a single execution of the program, yet the determinacy facts it infers hold for any execution. We present a formal soundness proof of the analysis for a simple imperative language, and a prototype implementation that handles full JavaScript. Finally, we report on two case studies that explored how static analysis for JavaScript could leverage the information gathered by dynamic determinacy analysis. We found that in some cases scalability of static pointer analysis was improved dramatically, and that many uses of runtime code generation could be eliminated.",,,,,34th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)34th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI),"JUN 16-19, 2013JUN 16-19, 2013",ACM SIGPLANACM SIGPLAN,"Seattle, WASeattle, WA",24,1,0,0,0,0,25,,,0362-1340,,,WOS:000321865400017,
C,"Rosu, Grigore; Stefanescu, Andrei; Ciobaca, Stefan; Moore, Brandon M.",,,IEEE Comp Soc,,,,,One-Path Reachability Logic,,,,,,,,2013 28TH ANNUAL IEEE/ACM SYMPOSIUM ON LOGIC IN COMPUTER SCIENCE (LICS),,IEEE Symposium on Logic in Computer Science,,,,,,358,367,,10.1109/LICS.2013.42,,,,2013,2013,"This paper introduces (one-path) reachability logic, a language-independent proof system for program verification, which takes an operational semantics as axioms and derives reachability rules, which generalize Hoare triples. This system improves on previous work by allowing operational semantics given with conditional rewrite rules, which are known to support all major styles of operational semantics. In particular, Kahn's big-step and Plotkin's small-step semantic styles are now supported. The reachability logic proof system is shown sound (i.e., partially correct) and (relatively) complete. Reachability logic thus eliminates the need to independently define an axiomatic and an operational semantics for each language, and the non-negligible effort to prove the former sound and complete w.r.t. the latter. The soundness result has also been formalized in Coq, allowing reachability logic derivations to serve as formal proof certificates that rely only on the operational semantics.",,,,,28th Annual IEEE/ACM Symposium on Logic in Computer Science (LICS)28th Annual IEEE/ACM Symposium on Logic in Computer Science (LICS),"JUN 25-28, 2013JUN 25-28, 2013",IEEE; ACM; ACM Special Interest Grp Algorithms & Computat Theory; IEEE Comp Soc; Assoc Symbol Log; IEEE Tech Comm Math Fdn Comp; European Assoc Theoret Comp SciIEEE; ACM; ACM Special Interest Grp Algorithms & Computat Theory; IEEE Comp Soc; Assoc Symbol Log; IEEE Tech Comm Math Fdn Comp; European Assoc Theoret Comp Sci,"Tulane Univ, New Orleans, LATulane Univ, New Orleans, LA",25,0,0,0,0,0,25,,,1043-6871,,978-1-4799-0413-6,WOS:000326815000041,
J,"Appel, Andrew W.; Dockins, Robert; Leroy, Xavier",,,,,"Appel, Andrew/0000-0001-6009-0325",,,A List-Machine Benchmark for Mechanized Metatheory,,,,,,,,JOURNAL OF AUTOMATED REASONING,,,,49,3,SI,,453,491,,10.1007/s10817-011-9226-1,,,,OCT 2012,2012,"We propose a benchmark to compare theorem-proving systems on their ability to express proofs of compiler correctness. In contrast to the first POPLmark, we emphasize the connection of proofs to compiler implementations, and we point out that much can be done without binders or alpha-conversion. We propose specific criteria for evaluating the utility of mechanized metatheory systems; we have constructed solutions in both Coq and Twelf metatheory, and we draw conclusions about those two systems in particular.",,,,,,,,,5,0,0,0,0,0,5,,,0168-7433,1573-0670,,WOS:000307334900007,
J,"Myreen, Magnus O.; Owens, Scott",,,,,"Owens, Scott/0000-0002-7437-4780",,,Proof-Producing Synthesis of ML from Higher-Order Logic,,,,,,,,ACM SIGPLAN NOTICES,,,,47,9,,,115,126,,10.1145/2398856.2364545,,,,SEP 2012,2012,"The higher-order logic found in proof assistants such as Coq and various HOL systems provides a convenient setting for the development and verification of pure functional programs. However, to efficiently run these programs, they must be converted (or extracted) to functional programs in a programming language such as ML or Haskell. With current techniques, this step, which must be trusted, relates similar looking objects that have very different semantic definitions, such as the set-theoretic model of a logic and the operational semantics of a programming language.In this paper, we show how to increase the trustworthiness of this step with an automated technique. Given a functional program expressed in higher-order logic, our technique provides the corresponding program for a functional language defined with an operational semantics, and it provides a mechanically checked theorem relating the two. This theorem can then be used to transfer verified properties of the logical function to the program.We have implemented our technique in the HOL4 theorem prover, translating functions to a core subset of Standard ML, and have applied it to examples including functional data structures, a parser generator, cryptographic algorithms, and a garbage collector.",,,,,17th ACM SIGPLAN International Conference on Functional Programming17th ACM SIGPLAN International Conference on Functional Programming,"SEP 09-15, 2012SEP 09-15, 2012",,"Copenhagen, DENMARKCopenhagen, DENMARK",6,0,0,0,0,0,6,,,0362-1340,1558-1160,,WOS:000311296000012,
J,"Danielsson, Nils Anders",,,,,,,,Operational Semantics Using the Partiality Monad,,,,,,,,ACM SIGPLAN NOTICES,,,,47,9,,,127,138,,10.1145/2398856.2364546,,,,SEP 2012,2012,"The operational semantics of a partial, functional language is often given as a relation rather than as a function. The latter approach is arguably more natural: if the language is functional, why not take advantage of this when defining the semantics? One can immediately see that a functional semantics is deterministic and, in a constructive setting, computable.This paper shows how one can use the coinductive partiality monad to define big-step or small-step operational semantics for lambda-calculi and virtual machines as total, computable functions (total definitional interpreters). To demonstrate that the resulting semantics are useful type soundness and compiler correctness results are also proved. The results have been implemented and checked using Agda, a dependently typed programming language and proof assistant.",,,,,17th ACM SIGPLAN International Conference on Functional Programming17th ACM SIGPLAN International Conference on Functional Programming,"SEP 09-15, 2012SEP 09-15, 2012",,"Copenhagen, DENMARKCopenhagen, DENMARK",22,0,0,0,0,0,22,,,0362-1340,1558-1160,,WOS:000311296000013,
J,"Dal Lago, Ugo; Zorzi, Margherita",,,,"Dal Lago, Ugo/AAA-6022-2020; Dal Lago, Ugo/K-9621-2015","Dal Lago, Ugo/0000-0001-9200-070X; Dal Lago, Ugo/0000-0001-9200-070X; Zorzi, Margherita/0000-0002-3285-9827",,,PROBABILISTIC OPERATIONAL SEMANTICS FOR THE LAMBDA CALCULUS,,,,,,,,RAIRO-THEORETICAL INFORMATICS AND APPLICATIONS,,,,46,3,,,413,450,,10.1051/ita/2012012,,,,JUL 2012,2012,"Probabilistic operational semantics for a nondeterministic extension of pure lambda-calculus is studied. In this semantics, a term evaluates to a (finite or infinite) distribution of values. Small-step and big-step semantics, inductively and coinductively defined, are given. Moreover, small-step and big-step semantics are shown to produce identical outcomes, both in call-by-value and in call-by-name. Plotkin's CPS translation is extended to accommodate the choice operator and shown correct with respect to the operational semantics. Finally, the expressive power of the obtained system is studied: the calculus is shown to be sound and complete with respect to computable probability distributions.",,,,,,,,,45,0,0,0,0,0,45,,,0988-3754,1290-385X,,WOS:000307453500005,
C,"Ancona, Davide",,,,,,"Noble, J",,Soundness of Object-Oriented Languages with Coinductive Big-Step Semantics,,,,,,,,ECOOP 2012 - OBJECT-ORIENTED PROGRAMMING,,Lecture Notes in Computer Science,,7313,,,,459,483,,,,,,2012,2012,"It is well known that big-step operational semantics are not suitable for proving soundness of type systems, because of their inability to distinguish stuck from non-terminating computations. We show how this problem can be solved by interpreting coinductively the rules for the standard big-step operational semantics of a Java-like language, thus making the claim of soundness more intuitive: whenever a program is well-typed, its coinductive operational semantics returns a value.Indeed, coinduction allows non-terminating computations to return values; this is proved by showing that the set of proof trees defining the semantic judgment forms a complete metric space when equipped with a proper distance function.In this way, we are able to prove soundness of a nominal type system w.r.t. the coinductive semantics. Since the coinductive semantics is sound w.r.t. the usual small-step operational semantics, the standard claim of soundness can be easily deduced.",,,,,26th European Conference on Object-Oriented Programming (ECOOP)26th European Conference on Object-Oriented Programming (ECOOP),"JUN 11-16, 2012JUN 11-16, 2012","Purdue Univ, Comp Sci Dept; Assoc Int Technol Objets; ACM SIGPLAN; ACM SIGSOFT; Adobe; ORACLE; Microsoft Res; LOGICBLOX; IBM Res; vmwarePurdue Univ, Comp Sci Dept; Assoc Int Technol Objets; ACM SIGPLAN; ACM SIGSOFT; Adobe; ORACLE; Microsoft Res; LOGICBLOX; IBM Res; vmware","Beijing, PEOPLES R CHINABeijing, PEOPLES R CHINA",7,0,0,0,0,0,7,,,0302-9743,,978-3-642-31057-7; 978-3-642-31056-0,WOS:000371250200021,
C,"Herms, Paolo; Marche, Claude; Monate, Benjamin",,,,,,"Joshi, R; Muller, P; Podelski, A",,A Certified Multi-prover Verification Condition Generator,,,,,,,,"VERIFIED SOFTWARE: THEORIES, TOOLS, EXPERIMENTS",,Lecture Notes in Computer Science,,7152,,,,2,+,,,,,,2012,2012,"Deduction-based software verification tools have reached a maturity allowing them to be used in industrial context where a very high level of assurance is required. This raises the question of the level of confidence we can grant to the tools themselves. We present a certified implementation of a verification condition generator. An originality is its genericity with respect to the logical context, which allows us to produce proof obligations for a large class of theorem provers.",,,,,"4th International Conference on Verified Software: Theories, Tool and Experiments (VSTTE 2012)4th International Conference on Verified Software: Theories, Tool and Experiments (VSTTE 2012)","JAN 28-29, 2012JAN 28-29, 2012",,"Philadelphia, PAPhiladelphia, PA",8,0,0,0,0,0,8,,,0302-9743,1611-3349,978-3-642-27704-7,WOS:000306943500002,
C,"Rosu, Grigore; Stefanescu, Andrei",,,,,,"Czumaj, A; Mehlhorn, K; Pitts, A; Wattenhofer, R",,Towards a Unified Theory of Operational and Axiomatic Semantics,,,,,,,,"AUTOMATA, LANGUAGES, AND PROGRAMMING, ICALP 2012, PT II",,Lecture Notes in Computer Science,,7392,,,,351,363,,,,,,2012,2012,"This paper presents a nine-rule language-independent proof system that takes an operational semantics as axioms and derives program reachability properties, including ones corresponding to Hoare triples. This eliminates the need for language-specific Hoare-style proof rules to verify programs, and, implicitly, the tedious step of proving such proof rules sound for each language separately. The key proof rule is Circularity, which is coinductive in nature and allows for reasoning about constructs with repetitive behaviors (e. g., loops). The generic proof system is shown sound and has been implemented in the MatchC verifier.",,,,,"39th International Colloquium on Automata, Languages, and Programming (ICALP)39th International Colloquium on Automata, Languages, and Programming (ICALP)","JUL 09-SEP 13, 2012JUL 09-SEP 13, 2012",Microsoft Res; Springer Verlag; European Assoc Theoret Comp Sci; Ctr Discrete Math ApplicatMicrosoft Res; Springer Verlag; European Assoc Theoret Comp Sci; Ctr Discrete Math Applicat,"Univ Warwick, Warwick, UNITED KINGDOMUniv Warwick, Warwick, UNITED KINGDOM",15,0,0,0,0,0,15,,,0302-9743,1611-3349,978-3-642-31585-5,WOS:000342761300033,
C,"Cave, Andrew; Pientka, Brigitte",,,ACM,,,,,Programming with Binders and Indexed Data-Types,,,,,,,,POPL 12: PROCEEDINGS OF THE 39TH ANNUAL ACM SIGPLAN-SIGACT SYMPOSIUM ON PRINCIPLES OF PROGRAMMING LANGUAGES,,,,,,,,413,424,,,,,,2012,2012,"We show how to combine a general purpose type system for an existing language with support for programming with binders and contexts by refining the type system of ML with a restricted form of dependent types where index objects are drawn from contextual LF. This allows the user to specify formal systems within the logical framework LF and index ML types with contextual LF objects. Our language design keeps the index language generic only requiring decidability of equality of the index language providing a modular design. To illustrate the elegance and effectiveness of our language, we give programs for closure conversion and normalization by evaluation.Our three key technical contribution are: 1) We give a bidirectional type system for our core language which is centered around refinement substitutions instead of constraint solving. As a consequence, type checking is decidable and easy to trust, although constraint solving may be undecidable. 2) We give a big-step environment based operational semantics with environments which lends itself to efficient implementation. 3) We prove our language to be type safe and have mechanized our theoretical development in the proof assistant Coq using the fresh approach to binding.",,,,,39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,"JAN 25-27, 2012JAN 25-27, 2012",ACM SIGPLAN; SIGACTACM SIGPLAN; SIGACT,"Philadelphia, PAPhiladelphia, PA",15,0,0,0,0,0,15,,,,,978-1-4503-1083-3,WOS:000304130100035,
